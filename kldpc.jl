module KLDPC

include("./myfunc.jl")

using DelimitedFiles
using SparseArrays
import .MyFunc

# export LDPC

@enum EqlNodeMode EQLINNER=1 EQLOUTER=2 EQLINNER_WO_CALC=3 EQLOUTER_WO_CALC=4 EQLINIT_LLRIN=5 EQLINIT_LLROUT=6

mutable struct GenMat
    path :: String
    G :: BitMatrix
    num_info_bit :: Int
    num_code_bit :: Int

    # GenMat(path, G, num_info_bit, num_code_bit) = new(path, G, num_info_bit, num_code_bit)

    function GenMat(path :: String)
        # generate from alist file

        file_array = readdlm(path)
        num_code_bit = file_array[1,1]
        num_info_bit = file_array[1,2]
        deg_col = file_array[3,:]
        G = falses(num_info_bit, num_code_bit)
        for n = 5 : 4 + num_code_bit
            vec = file_array[n,:]
            for k = 1 : deg_col[n-4]
                G[vec[k] ,n-4] = true
            end
        end
        return new(path, G, num_info_bit, num_code_bit)
    end

    function GenMat(G :: BitMatrix)
        # generate from matrix G

        (num_info_bit, num_code_bit) = size(G)
        path = "generated by G"
        return new(path, G, num_info_bit, num_code_bit)
    end

    function GenMat()
        # generate an empty object

        num_info_bit = 0
        num_code_bit = 0
        path = "empty"
        G = BitArray(undef, 0, 0)
        return new(path, G, num_info_bit, num_code_bit)
    end
end


mutable struct ParMat
    path :: String
    H :: SparseMatrixCSC{Bool, Int}
    I :: Vector{Int}
    J :: Vector{Int}
    Hidx :: Vector{Vector{Int64}}
    num_par_bit :: Int
    num_code_bit :: Int
    num_edge :: Int

    # ParMat(path, H, num_par_bit, num_code_bit) = new(path, H, num_par_bit, num_code_bit)

    function ParMat(path :: String)
        file_array = readdlm(path)
        num_code_bit = file_array[1,1]
        num_par_bit = file_array[1,2]
        deg_col = file_array[3,:]
        H = spzeros(Bool, Int, num_par_bit, num_code_bit)
        for n = 5 : 4 + num_code_bit
            vec = file_array[n,:]
            for k = 1 : deg_col[n-4]
                H[vec[k] ,n-4] = true
            end
        end
        num_edge = nnz(H)
        (I, J, V) = findnz(H)
        Hidx = Vector{Vector{Int64}}(undef, 0)
        for m = 1 : num_par_bit
            push!(Hidx, Int64[])
        end
        for n = 1 : num_edge
            push!(Hidx[I[n]], J[n])
        end

        return new(path, H, I, J, Hidx, num_par_bit, num_code_bit, num_edge)
    end
end

function parcheck(parmat :: ParMat, cw :: BitVector)
    if length(cw) != parmat.num_code_bit
        throw("Wrong codeword length !")
    end

    iscodeword = true # initialize

    for hidx in parmat.Hidx
        tmp = false
        for idx in hidx
            tmp = tmp ⊻ cw[idx]
        end
        if tmp == true
            iscodeword = false
            break
        end
    end

    return iscodeword
end

abstract type Edge end

mutable struct BinEdgeLDPC <: Edge
    idx :: Int
    LLR2chk :: Float64
    idx_chk :: Int
    LLR2eql :: Float64
    idx_eql :: Int
    # BinEdge(idx , LLR1, LLR2, idx1, idx2) = new(idx, LLR1, LLR2, idx1, idx2)
    BinEdgeLDPC() = new(0, 0.0, 0, 0.0, 0)
    BinEdgeLDPC(idx :: Int) = new(idx, 0.0, 0, 0.0, 0)
end

mutable struct HalfBinEdge <: Edge
    # used for receiving LDPC codeword from channel
    idx :: Int
    LLR2eql :: Float64
    idx_eql :: Int
    HalfBinEdge() = new(0, 0.0, 0)
    HalfBinEdge(idx :: Int) = new(idx, 0.0, 0)
end

abstract type Node end

mutable struct EqlNode <: Node
    idx :: Int
    deg_chk :: Int
    edgevec2chk :: Vector{BinEdgeLDPC}
    deg_out :: Int
    edgevec2out :: Vector{Edge}
    sumLLR :: Float64
    sumLLRin :: Float64 # sum LLR from inner edge
    sumLLRout :: Float64 # sum LLR from outer edge
    # EqlNode(idx, deg_chk, idx_chk, deg_out, idx_out) = new(idx, deg_chk, idx_chk, deg_out, idx_out)
    EqlNode() = new(0, 0, [], 0, [], 0.0, 0.0, 0.0)
    EqlNode(idx :: Int) = new(idx, 0, [], 0, [], 0.0, 0.0, 0.0)
end

function (eql :: EqlNode)(mode :: EqlNodeMode)
    if mode == EQLINNER # only pass message to check node (inner)
        eql.sumLLRin = 0.0
        for edge in eql.edgevec2chk
            eql.sumLLRin += edge.LLR2eql
        end
        eql.sumLLR = eql.sumLLRin + eql.sumLLRout
        for edge in eql.edgevec2chk
            edge.LLR2chk = eql.sumLLR - edge.LLR2eql
        end
    elseif mode == EQLOUTER # only pass message to outer edge
        eql.sumLLRout = 0.0
        for edge in eql.edgevec2out
            eql.sumLLRout += edge.LLR2eql
        end
        eql.sumLLR = eql.sumLLRin + eql.sumLLRout
        for edge in eql.edgevec2out
            edge.LLR2chk = eql.sumLLR - edge.LLR2eql
        end
    elseif mode == EQLINNER_WO_CALC # pass msg to inner, without calculating sum LLR
        for edge in eql.edgevec2chk
            edge.LLR2chk = eql.sumLLR - edge.LLR2eql
        end
    elseif mode == EQLOUTER_WO_CALC # pass msg to outer, without calculating sum LLR
        for edge in eql.edgevec2out
            edge.LLR2chk = eql.sumLLR - edge.LLR2eql
        end
    elseif mode == EQLINIT_LLROUT # initialize sumLLRout, those edge from outer
        eql.sumLLRout = 0.0
        for edge in eql.edgevec2out
            eql.sumLLRout += edge.LLR2eql
        end
    elseif mode == EQLINIT_LLRIN # initialize sumLLRin, those edge from inner
        eql.sumLLRin = 0.0
        for edge in eql.edgevec2chk
            eql.sumLLRin += edge.LLR2eql
        end
    else
        throw(ArgumentError("Wrong message passing mode"))
    end
end

mutable struct ChkNode <: Node
    idx :: Int
    deg_eql :: Int
    edgevec2eql :: Vector{BinEdgeLDPC}
    # ChkNode(idx, deg_eql, idx_eql) = new(idx, deg_eql, idx_eql)
    ChkNode() = new(0, 0, [])
    ChkNode(idx :: Int) = new(idx, 0, [])
end

function (chk :: ChkNode)()
    # pass msg to all the edges
    LLRin = Vector{Float64}(undef, chk.deg_eql)
    for n = 1 : chk.deg_eql
        LLRin[n] = chk.edgevec2eql[n].LLR2chk
    end
    LLRout = boxplusvec(LLRin)
    for n = 1 : chk.deg_eql
        chk.edgevec2eql[n].LLR2eql = LLRout[n]
    end

end

function cnct!(edge :: BinEdgeLDPC, chk :: ChkNode, eql :: EqlNode)
    edge.idx_chk = chk.idx
    edge.idx_eql = eql.idx
    push!(chk.edgevec2eql, edge) # point to the same edge object
    chk.deg_eql += 1
    push!(eql.edgevec2chk, edge) # point to the same edge object
    eql.deg_chk += 1
end

function cnct!(edge :: HalfBinEdge, eql :: EqlNode)
    edge.idx_eql = eql.idx
    push!(eql.edgevec2out, edge) #  point to the same edge object
    eql.deg_out += 1
end


mutable struct LDPC
    genmat :: GenMat
    parmat :: ParMat
    eqlvec :: Vector{EqlNode}
    chkvec :: Vector{ChkNode}
    edgevec :: Vector{BinEdgeLDPC}
    num_code_bit :: Int
    num_info_bit :: Int
    num_par_bit :: Int
    rate :: Float64
    nummaxiter :: Int
    hedgevec :: Vector{HalfBinEdge}

    function LDPC(G_path :: String, H_path :: String, nummaxiter :: Int = 10000)
        genmat = GenMat(G_path)
        parmat = ParMat(H_path)
        num_code_bit = genmat.num_code_bit
        num_info_bit = genmat.num_info_bit
        num_par_bit = parmat.num_par_bit
        eqlvec = Vector{EqlNode}(undef, num_code_bit)
        chkvec = Vector{ChkNode}(undef, num_par_bit)
        edgevec = Vector{BinEdgeLDPC}(undef, parmat.num_edge)
        rate = num_info_bit / num_code_bit

        for n = 1 : num_code_bit
            eqlvec[n] = EqlNode(n)
        end

        for m = 1 : num_par_bit
            chkvec[m] = ChkNode(m)
        end

        for eg = 1 : parmat.num_edge
            edgevec[eg] = BinEdgeLDPC(eg)
            cnct!(edgevec[eg], chkvec[parmat.I[eg]], eqlvec[parmat.J[eg]])
        end

        return new(genmat, parmat, eqlvec, chkvec, edgevec , num_code_bit, num_info_bit, num_par_bit, rate, nummaxiter, [])
    end
end

function encode(C :: LDPC, data :: BitVector)
    return MyFunc.andsum(data, C.genmat.G)
end

function init!(C :: LDPC)
    # used for receiving LDPC codeword from channel
    C.hedgevec = Vector{HalfBinEdge}(undef, C.num_code_bit)
    for n = 1 : C.num_code_bit
        C.hedgevec[n] = HalfBinEdge(n)
        cnct!(C.hedgevec[n], C.eqlvec[n])
    end
end

function rxinit!(C :: LDPC, rx_LLR :: Array{Float64,1})
    # used for receiving LDPC codeword from channel
    # clear the edge LLR

    for n = 1 : C.num_code_bit
        C.hedgevec[n].LLR2eql = rx_LLR[n]
    end
    for edge in C.edgevec
        edge.LLR2eql = 0.0
        edge.LLR2chk = 0.0
    end
end

function rxinit!(C :: LDPC)
    # clear the LDPC inner edge LLR

    for edge in C.edgevec
        edge.LLR2eql = 0.0
        edge.LLR2chk = 0.0
    end

    # for eql in C.eqlvec
    #     eql.sumLLR = 0.0
    #     eql.sumLLRin = 0.0
    #     eql.sumLLRout = 0.0
    # end
end

function getcw(C :: LDPC)
    cw = BitVector(undef, C.num_code_bit)
    for eql in C.eqlvec
        cw[eql.idx] = (eql.sumLLR < 0)
    end
    return cw
end

function getdata(C :: LDPC, rec_cw :: BitVector)
    return rec_cw[C.num_par_bit+1 : end]
end

function parcheck(C :: LDPC,  cw :: BitVector)
    return parcheck(C.parmat, cw)
end

function decode!(C :: LDPC, rx_LLR :: Array{Float64,1})
    # used for receiving LDPC codeword from channel

    rxinit!(C, rx_LLR)
    rec_cw = BitVector(undef, C.num_code_bit)
    for eql in C.eqlvec
        eql(EQLINIT_LLROUT)
    end

    for iter = 1 : C.nummaxiter
        for eql in C.eqlvec
            eql(EQLINNER)
        end
        rec_cw = getcw(C)
        if parcheck(C, rec_cw) == true
            break
        end
        for chk in C.chkvec
            chk()
        end
    end
    return getdata(C, rec_cw)
end

function msgpass!(C :: LDPC, numiter :: Int)
    # used for Raptor Code, inner msg passing
    # if converge to a valid codeword, return the decoded data

    iscw = false
    rec_cw = BitVector(undef, C.num_code_bit)
    for eql in C.eqlvec
        eql(EQLINIT_LLROUT)
    end

    for iter = 1 : numiter
        for chk in C.chkvec
            chk()
        end
        for eql in C.eqlvec
            eql(EQLINNER)
        end
        rec_cw = getcw(C)
        if parcheck(C, rec_cw) == true
            iscw = true
            break
        end
    end

    if iscw == true
        return (iscw, getdata(C, rec_cw))
    else
        for eql in C.eqlvec
            eql(EQLOUTER_WO_CALC)
        end
        return (iscw, [])
    end
end


function clearoutedge!(C :: LDPC)
    # clear the out edge connected to LDPC EqlNode
    C.hedgevec = Vector{HalfBinEdge}(undef,0)
    for eql in C.eqlvec
        eql.deg_out = 0
        eql.edgevec2out = Vector{Edge}(undef,0)
    end
end

function log1exp(x :: Float64)
    return log1p(exp(-x))
end

function boxplus(x :: Float64, y :: Float64)
    return sign(x) * sign(y) * min(abs(x), abs(y)) + log1exp(abs(x+y)) - log1exp(abs(x-y))
end

function boxplust(x :: Float64, y :: Float64)
    return 2.0 * atanh(tanh(x/2)*tanh(y/2))
end

function boxplusvec(x :: Vector{Float64})
    # calculate all boxplus combination of x
    # please see example when veclen == 2 or 3

    veclen = length(x)
    y = Vector{Float64}(undef, veclen)
    if veclen <= 1
        throw("Input length ≦ 1")
    elseif veclen == 2
        y[1] = x[2]
        y[2] = x[1]
    elseif veclen == 3
        y[1] = boxplus(x[2], x[3])
        y[2] = boxplus(x[1], x[3])
        y[3] = boxplus(x[1], x[2])
    else
        # Right Left (RL) method
        # mark boxplus(y, x0, x1) as y = (x0, x1), then
        # from left: calc (x0, x1), ( (x0, x1) , x2 ) , ( ( (x0, x1) , x2 ) , x3 ) , ...
        # from right: calc (x_m, x_m-1), ( (x_m, x_m-1) , x_m-2 ) , ...
        # save them, and calc each msg

        # initialize leftvec and rightvec
        rlveclen = veclen - 2
        leftvec = Vector{Float64}(undef, rlveclen)
        rightvec = Vector{Float64}(undef, rlveclen)

        leftvec[1] = boxplus(x[1], x[2])
        rightvec[1] = boxplus(x[end], x[end-1])

        # calculate leftvec and rightvec
        for n = 2 : rlveclen
            leftvec[n] = boxplus(leftvec[n-1], x[n+1])
            rightvec[n] = boxplus(rightvec[n-1], x[end-n])
        end

        # merge leftvec and rightvec to get the output y
        y[1] = rightvec[end]
        y[end] = leftvec[end]
        y[2] = boxplus(rightvec[end-1], x[1])
        y[end-1] = boxplus(leftvec[end-1], x[end])

        for n = 3 : rlveclen
            y[n] = boxplus(leftvec[n-2], rightvec[end-n+1])
        end
    end

    return y
end

end  # module KLDPC
